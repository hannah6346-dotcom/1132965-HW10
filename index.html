<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>1132965 - HW10</title>
    <style>
        body { background-color: #f0f0f0; display: flex; flex-direction: column; align-items: center; font-family: "Microsoft JhengHei", sans-serif; }
        .info { text-align: center; margin: 20px; padding: 15px; background: white; border-radius: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); width: 350px; }
        
        .board {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            gap: 4px;
            background-color: #1b5e20;
            padding: 10px;
            border-radius: 8px;
            perspective: 1000px;
        }
        
        .cell {
            width: 60px; height: 60px;
            background-color: #4caf50;
            display: flex; justify-content: center; align-items: center;
            position: relative; cursor: pointer;
        }

        /* 棋子主體 */
        .piece {
            width: 50px; height: 50px;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* 狀態控制：黑棋正面朝上(0度)，白棋反面朝上(180度) */
        .piece.is-black { transform: rotateY(0deg); }
        .piece.is-white { transform: rotateY(180deg); }

        .side {
            position: absolute; width: 100%; height: 100%;
            border-radius: 50%; backface-visibility: hidden;
            box-shadow: 0 4px 8px rgba(0,0,0,0.4);
        }
        
        .front { background: radial-gradient(circle at 30% 30%, #444, #000); }
        .back { 
            background: radial-gradient(circle at 30% 30%, #fff, #ccc); 
            transform: rotateY(180deg); 
        }

        .hint { width: 12px; height: 12px; background: rgba(0,0,0,0.15); border-radius: 50%; }
    </style>
</head>
<body>

<div class="info">
    <h2>11XXXXX - HW10</h2>
    <div id="status">輪到：黑棋 (玩家)</div>
    <div id="score">黑: 2 | 白: 2</div>
    <div style="margin-top:10px">
        AI 棋力: <select id="level"><option value="1">基本</option><option value="2">進階</option></select>
        <button onclick="initGame()">重新開始</button>
    </div>
</div>

<div id="board" class="board"></div>

<script>
let grid = Array(8).fill().map(() => Array(8).fill(0));
let turn = 1; 
let isAnimating = false;

// 初始化棋盤 DOM (只建立一次)
function createBoard() {
    const boardEl = document.getElementById('board');
    boardEl.innerHTML = '';
    for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.id = `cell-${r}-${c}`;
            cell.onclick = () => handlePlayerMove(r, c);
            boardEl.appendChild(cell);
        }
    }
}

function initGame() {
    grid = Array(8).fill().map(() => Array(8).fill(0));
    isAnimating = false;
    turn = 1;
    // 清除所有棋子 DOM
    document.querySelectorAll('.cell').forEach(c => c.innerHTML = '');
    
    // 初始四子
    setPiece(3, 3, 2); setPiece(3, 4, 1);
    setPiece(4, 3, 1); setPiece(4, 4, 2);
    
    updateDisplay();
}

// 放置或更新棋子，不重畫整個棋盤
function setPiece(r, c, color) {
    const cell = document.getElementById(`cell-${r}-${c}`);
    let piece = cell.querySelector('.piece');
    
    if (!piece) {
        // 如果格子是空的，建立新棋子
        piece = document.createElement('div');
        piece.className = 'piece';
        piece.innerHTML = '<div class="side front"></div><div class="side back"></div>';
        cell.appendChild(piece);
    }
    
    // 強制觸發重繪以確保動畫執行
    setTimeout(() => {
        piece.className = `piece ${color === 1 ? 'is-black' : 'is-white'}`;
    }, 10);
    
    grid[r][c] = color;
}

function updateDisplay() {
    let b = 0, w = 0;
    for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            const cell = document.getElementById(`cell-${r}-${c}`);
            const hint = cell.querySelector('.hint');
            if (grid[r][c] === 0) {
                if (getFlips(r, c, turn).length > 0) {
                    if (!hint) {
                        const h = document.createElement('div');
                        h.className = 'hint';
                        cell.appendChild(h);
                    }
                } else if (hint) {
                    hint.remove();
                }
            } else if (hint) {
                hint.remove();
            }
            if (grid[r][c] === 1) b++;
            if (grid[r][c] === 2) w++;
        }
    }
    document.getElementById('score').innerText = `黑: ${b} | 白: ${w}`;
}

async function handlePlayerMove(r, c) {
    if (isAnimating || turn !== 1) return;
    const flips = getFlips(r, c, 1);
    if (flips.length === 0) return;

    isAnimating = true;
    setPiece(r, c, 1); // 玩家落子
    await executeFlips(flips, 1);
    
    turn = 2;
    document.getElementById('status').innerText = "輪到：白棋 (電腦)";
    updateDisplay();
    setTimeout(aiMove, 800);
}

async function aiMove() {
    const moves = [];
    for(let r=0; r<8; r++) {
        for(let c=0; c<8; c++) {
            const f = getFlips(r, c, 2);
            if(f.length > 0) moves.push({r, c, f});
        }
    }

    if (moves.length > 0) {
        const weights = [[100,-20,10,10,10,10,-20,100],[-20,-50,1,1,1,1,-50,-20],[10,1,5,2,2,5,1,10],[10,1,2,1,1,2,1,10],[10,1,2,1,1,2,1,10],[10,1,5,2,2,5,1,10],[-20,-50,1,1,1,1,-50,-20],[100,-20,10,10,10,10,-20,100]];
        const isPro = document.getElementById('level').value === "2";
        moves.sort((a, b) => isPro ? (weights[b.r][b.c] - weights[a.r][a.c]) : (b.f.length - a.f.length));
        
        const best = moves[0];
        setPiece(best.r, best.c, 2); // 電腦落子
        await executeFlips(best.f, 2);
    }

    turn = 1;
    isAnimating = false;
    document.getElementById('status').innerText = "輪到：黑棋 (玩家)";
    updateDisplay();
}

// 核心動畫邏輯：依序翻轉
async function executeFlips(flippable, color) {
    // 移除所有提示點，避免動畫時干擾
    document.querySelectorAll('.hint').forEach(h => h.remove());
    
    for (let pos of flippable) {
        await new Promise(res => setTimeout(res, 200)); // 翻轉間隔
        setPiece(pos.r, pos.c, color);
    }
}

function getFlips(r, c, color) {
    if (grid[r][c] !== 0) return [];
    const opp = color === 1 ? 2 : 1;
    const dirs = [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[-1,1],[1,-1],[1,1]];
    let res = [];
    for (let [dr, dc] of dirs) {
        let temp = [], cr = r + dr, cc = c + dc;
        while (cr>=0 && cr<8 && cc>=0 && cc<8 && grid[cr][cc] === opp) {
            temp.push({r: cr, c: cc});
            cr += dr; cc += dc;
        }
        if (cr>=0 && cr<8 && cc>=0 && cc<8 && grid[cr][cc] === color) res = res.concat(temp);
    }
    return res;
}

createBoard();
initGame();
</script>
</body>
</html>
