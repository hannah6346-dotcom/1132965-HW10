<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1132965 - HW10</title>
    <style>
        :root {
            --board-color: #2e7d32;
            --cell-color: #4caf50;
            --cell-border: #1b5e20;
        }

        body {
            font-family: "Microsoft JhengHei", Arial, sans-serif;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .info-panel {
            background: white;
            padding: 15px 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            text-align: center;
        }

        .status {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 10px;
        }

        /* 棋盤設計 */
        .board {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            gap: 2px;
            background-color: var(--cell-border);
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .cell {
            width: 60px;
            height: 60px;
            background-color: var(--cell-color);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
        }

        .cell:hover {
            background-color: #66bb6a;
        }

        /* 立體棋子與 3D 翻轉效果 */
        .piece-container {
            width: 50px;
            height: 50px;
            position: relative;
            transition: transform 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            transform-style: preserve-3d;
        }

        /* 控制翻轉狀態 */
        .piece-container.white-side {
            transform: rotateY(180deg);
        }

        .piece-front, .piece-back {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            backface-visibility: hidden;
            box-shadow: 0 4px 4px rgba(0,0,0,0.3);
        }

        /* 黑子面 (正面) */
        .piece-front {
            background: radial-gradient(circle at 30% 30%, #444, #000);
            z-index: 2;
        }

        /* 白子面 (反面) */
        .piece-back {
            background: radial-gradient(circle at 30% 30%, #fff, #ccc);
            transform: rotateY(180deg);
        }

        .hint {
            width: 15px;
            height: 15px;
            background-color: rgba(0,0,0,0.1);
            border-radius: 50%;
        }

        .controls {
            margin-top: 20px;
        }

        select, button {
            padding: 8px 15px;
            font-size: 1rem;
            cursor: pointer;
        }
    </style>
</head>
<body>

    <div class="info-panel">
        <h1>Othello 黑白棋</h1>
        <div class="status" id="turn-text">輪到：黑棋 (玩家)</div>
        <div id="score">黑棋: 2 | 白棋: 2</div>
        
        <div class="controls">
            <label>AI 難度：</label>
            <select id="difficulty">
                <option value="basic">基本棋力 (貪婪法)</option>
                <option value="advanced">進階棋力 (權重評估)</option>
            </select>
            <button onclick="initGame()">重新開始</button>
        </div>
    </div>

    <div id="board" class="board"></div>

    <script>
        const BOARD_SIZE = 8;
        let board = [];
        let currentPlayer = 1; // 1: Black, 2: White
        let isLock = false;

        // 權重表 (進階 AI 用)
        const WEIGHTS = [
            [100, -20, 10, 5, 5, 10, -20, 100],
            [-20, -50, -2, -2, -2, -2, -50, -20],
            [10, -2, 5, 1, 1, 5, -2, 10],
            [5, -2, 1, 1, 1, 1, -2, 5],
            [5, -2, 1, 1, 1, 1, -2, 5],
            [10, -2, 5, 1, 1, 5, -2, 10],
            [-20, -50, -2, -2, -2, -2, -50, -20],
            [100, -20, 10, 5, 5, 10, -20, 100]
        ];

        function initGame() {
            board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
            board[3][3] = 2; board[3][4] = 1;
            board[4][3] = 1; board[4][4] = 2;
            currentPlayer = 1;
            isLock = false;
            renderBoard();
        }

        function renderBoard() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';
            let bCount = 0, wCount = 0;

            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.onclick = () => handleMove(r, c);

                    if (board[r][c] !== 0) {
                        const piece = document.createElement('div');
                        piece.className = 'piece-container';
                        if (board[r][c] === 2) piece.classList.add('white-side');
                        
                        const front = document.createElement('div');
                        front.className = 'piece-front';
                        const back = document.createElement('div');
                        back.className = 'piece-back';
                        
                        piece.appendChild(front);
                        piece.appendChild(back);
                        cell.appendChild(piece);
                        
                        if (board[r][c] === 1) bCount++; else wCount++;
                    } else if (canMove(r, c, currentPlayer)) {
                        const hint = document.createElement('div');
                        hint.className = 'hint';
                        cell.appendChild(hint);
                    }
                    boardEl.appendChild(cell);
                }
            }
            document.getElementById('score').innerText = `黑棋: ${bCount} | 白棋: ${wCount}`;
            updateTurnText();
        }

        function updateTurnText() {
            const text = currentPlayer === 1 ? "黑棋 (玩家)" : "白棋 (電腦)";
            document.getElementById('turn-text').innerText = `輪到：${text}`;
        }

        async function handleMove(r, c) {
            if (isLock || currentPlayer !== 1 || !canMove(r, c, 1)) return;
            await executeMove(r, c, 1);
            
            // 電腦回合
            if (hasAnyMove(2)) {
                isLock = true;
                setTimeout(computerTurn, 1000);
            } else if (!hasAnyMove(1)) {
                alert("遊戲結束！");
            } else {
                currentPlayer = 1;
                renderBoard();
            }
        }

        async function computerTurn() {
            const level = document.getElementById('difficulty').value;
            let move;
            if (level === 'basic') {
                move = getGreedyMove(2);
            } else {
                move = getBestMove(2);
            }

            if (move) {
                await executeMove(move.r, move.c, 2);
            }
            
            isLock = false;
            if (hasAnyMove(1)) {
                currentPlayer = 1;
            } else if (hasAnyMove(2)) {
                setTimeout(computerTurn, 1000);
            } else {
                alert("遊戲結束！");
            }
            renderBoard();
        }

        // 核心邏輯：執行落子與「依序翻棋」
        async function executeMove(r, c, color) {
            const flippable = getFlippable(r, c, color);
            board[r][c] = color;
            renderBoard(); // 先畫出落子

            // 依序翻棋效果
            for (let pos of flippable) {
                board[pos.r][pos.c] = color;
                await new Promise(res => setTimeout(res, 150)); // 間隔 150ms
                renderBoard();
            }
            currentPlayer = color === 1 ? 2 : 1;
        }

        function getFlippable(r, c, color) {
            const opponents = color === 1 ? 2 : 1;
            const directions = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
            let totalFlippable = [];

            for (let [dr, dc] of directions) {
                let temp = [];
                let currR = r + dr;
                let currC = c + dc;
                while (currR >= 0 && currR < 8 && currC >= 0 && currC < 8 && board[currR][currC] === opponents) {
                    temp.push({r: currR, c: currC});
                    currR += dr;
                    currC += dc;
                }
                if (currR >= 0 && currR < 8 && currC >= 0 && currC < 8 && board[currR][currC] === color) {
                    totalFlippable = totalFlippable.concat(temp);
                }
            }
            return totalFlippable;
        }

        function canMove(r, c, color) {
            if (board[r][c] !== 0) return false;
            return getFlippable(r, c, color).length > 0;
        }

        function hasAnyMove(color) {
            for (let r = 0; r < 8; r++)
                for (let c = 0; c < 8; c++)
                    if (canMove(r, c, color)) return true;
            return false;
        }

        // AI 邏輯
        function getGreedyMove(color) {
            let bestMove = null;
            let maxFlip = -1;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (canMove(r, c, color)) {
                        let count = getFlippable(r, c, color).length;
                        if (count > maxFlip) {
                            maxFlip = count;
                            bestMove = {r, c};
                        }
                    }
                }
            }
            return bestMove;
        }

        function getBestMove(color) {
            let bestScore = -Infinity;
            let bestMove = null;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (canMove(r, c, color)) {
                        let score = WEIGHTS[r][c];
                        if (score > bestScore) {
                            bestScore = score;
                            bestMove = {r, c};
                        }
                    }
                }
            }
            return bestMove || getGreedyMove(color);
        }

        initGame();
    </script>
</body>
</html>
